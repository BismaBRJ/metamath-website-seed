<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html><head><title>AsteroidMeta: MetamathForProgrammers</title><link type="text/css" rel="stylesheet" href="wiki.css" /><meta name="robots" content="INDEX,NOFOLLOW" /><link rel="alternate" type="application/rss+xml" title="AsteroidMeta" href="index.html@action=rss" /><link rel="alternate" type="application/rss+xml" title="AsteroidMeta: MetamathForProgrammers" href="http://planetx.cc.vt.edu/AsteroidMeta?action=rss;rcidonly=MetamathForProgrammers" /></head><body class="http://planetx.cc.vt.edu/AsteroidMeta"><div class="header"><span class="gotobar bar"><a class="local" href="HomePage">HomePage</a> <a class="local" href="RecentChanges">RecentChanges</a> </span><h1><a title="Click to search for references to this page" href="http://planetx.cc.vt.edu/AsteroidMeta?search=MetamathForProgrammers">MetamathForProgrammers</a></h1></div><div class="content browse"><p>I have been thinking about writing a small "book" (html w/.jpg diagrams) titled something like, "Metamath For Programmers", which with yellow and black on the cover would be similar in both intent and implementation to "Metamath For Dummies".</p><p>One reason this is a good idea is that I cannot yet begin writing mmj3 because I don't know enough about what are the interesting things that it should do.</p><p>Another reason is that the scholarly papers such as "AN AUTOMATIC THEOREM PROVER FOR SUBSTITUTION AND DETACHMENT SYSTEMS" by Jeremy George Peterson and Norm's "A Finitely Axiomatized Formalization of Predicate Calculus with Equality" are almost unapproachable and inscrutable without extensive background preparation (e.g. "An inference rule related to Rule D is the resolution principle of J. A. Robinson [16], commonly used in automated theorem proving. A deductive system of logic whose inference rules are resolution together with the related rules of factoring and paramodulation can be considered finitely axiomatized in our sense and can produce clauses (theorems) that correspond to Skolemizations of theorems of predicate calculus with equality. But such a system is not “deduction complete” so that, for example, G¨odel’s completeness theorem fails to hold [21].")</p><p>Furthermore, I believe that (geometric) tree-based algorithms, if described using diagrams and words, are easier to understand -- are more scrutable &#x2013; than the "loop and GOTO" algorithms such as Robinson's unification algorithm. And the tree algorithms are not just more <i>scrutable</i> they are more general, being so to speak, "language agnostic" (this builds upon the Metamath system which has only these built-in inference rules: typed valid simultaneous substitution and hypothesis reiteration (as in "dummylink").) Now that I have done the work to make mmj2 I can almost appreciate Condensed Detachement and Rule D, but there is no reason for others to have to suffer through all that. It should be possible to begin with Metamath and let interested students delve into its archeological history if they so desire.</p><p>Another example: I have just arrived at the conclusion that mmj2's StepUnifier<a class="edit" title="Click to edit this page" href="http://planetx.cc.vt.edu/AsteroidMeta?action=edit;id=StepUnifier">?</a>.java algorithm produces the Most General Unification if the input proof step contains only Work Variables. Therefore, I can now describe a method of unification based on recursive unification of parse sub-trees and variable renaming. This approach is based on performing sub-unifications until an inconsistency is found or there are no more subtrees: if unification of the <i>set</i> of formulas "A" with the <i>set</i> of formulas "B" produces no inconsistencies, then the resulting set of simultaneous substitutions from A into B are "consistent". Type checking of substitutions is required for the "validity" portion of the description, as is $d checking which is outside the scope of the StepUnifier<a class="edit" title="Click to edit this page" href="http://planetx.cc.vt.edu/AsteroidMeta?action=edit;id=StepUnifier">?</a>'s mandate (it might be possible to integrate $d checking &#x2013; that is a subject worthy of more research.)</p><p>(((I am also interested because Peterson's paper goes in exactly the same direction I went with my idea about generating all possible theorems and then writing them out in the most compact form possible as a list of numbers. His "theorem prover" is in actuality a theorem <i>generator</i>, and note that his primary "heuristic" was limiting the length of stored formulas during the generation process.)))</p><p>I can also equate the Metamath Proof Verification Algorithm directly to the other tree-based unification algorithm which does not use Work Variables (in ProofUnifier<a class="edit" title="Click to edit this page" href="http://planetx.cc.vt.edu/AsteroidMeta?action=edit;id=ProofUnifier">?</a>.java). They are the same thing except that the former uses RPN lists and the latter uses trees. And, as with unification, the fact that the Metamath algorithm may be more efficient is less relevant in this era of fast, cheap computers if the tree methods are easier to understand (anyway, once the tree method is explained and accepted, it is easy to demonstrate that a valid tree can be converted to an RPN list, and vice-versa.)</p><p>I think that the beauty and elegance of Metamath is offset &#x2013; for programmers &#x2013; by the unnecessarily difficult background material which can be explained in a more modern style. Then with the subjects mentioned above as a foundation, along with other topics such as building a grammar from a .mm file and parsing, the way will be clear for others to perform much additional work! For example:</p><ul><li>Efficient Unification Searching methods for .mm systems containing 1 million or more assertions;</li><li>Exportation/Importation of theorems between different .mm databases (as well as the intimately associated problem of database synchronization), and between completely different proving systems and calculi.)</li><li>Exploring Peterson's path of generating all possible non- duplicative theorems of a given maximum length as a way to rapidly build a new .mm database from experimental axioms (the research possibilities here are vastly underappreciated in my opinion given the imminent development of nanotech computing and data storage devices &#x2013; and there might even be an artistic element here similar to studies of the Mandelbrot Set.)</li><li>And of course, the Holy Grail, which is logic-agnostic automated theorem proving, especially for use with in Proof Assistancy.</li><li>And the <i>other</i> Holy Grail, which is to move the Proof Assistant into standard 3D virtual reality environments, complete with speech I/O and V/R I/O devices (like V/R gloves.)</li></ul><p>I believe that once the mysterious and inscrutable parts of Metamath are better explained it is likely that many more programmers will begin work to advance the state of the art (and America can defeat the armies of EU-funded programmers working on Omega :-)</p><hr /><p>FYI, I started diagramming the MObj class hierarchy, with small, possible forward-looking "enhancements", and it took quite a lot of work. That hierarchy isn't even 1/3 of the mmj2 classes either. The amount of work involved in just re-documenting mmj2, to say nothing of designing an mmj3, or writing a book is mind-boggling. It makes my ass hurt just thinking about how long I sat at this desk writing the mmj2 code. I have to say, I am pretty happy that we have mmj2 now considering how much work went into it and the fact that it actually works pretty well.</p><p>That said, the <i>project</i> of analyzing Metamath in view of everything we have discovered (i.e. figured out what Norm already knew) is definitely worthwhile. There are still many discoveries to be made!</p><p>BTW, Dia version 0.96.1 has some bugs. Lots of shapes, especially grievously, the UML shapes, are not resizeable. The little black squares should be green, but instead are just static and useless. I ended up doing my diagrams using the basic drawing elements and the UML arrows. Sigh. (Better than paper and pencil, but worse than Visio (which I paid for once, but which was rendered unusable in WinXP<a class="edit" title="Click to edit this page" href="http://planetx.cc.vt.edu/AsteroidMeta?action=edit;id=WinXP">?</a>, for some reason.)) </p></div><div class="footer"><hr /><span class="gotobar bar"><a class="local" href="HomePage">HomePage</a> <a class="local" href="RecentChanges">RecentChanges</a> </span><span class="edit bar"><br /> <a class="edit" accesskey="e" title="Click to edit this page" href="http://planetx.cc.vt.edu/AsteroidMeta?action=edit;id=MetamathForProgrammers">Edit this page</a> <a class="history" href="http://planetx.cc.vt.edu/AsteroidMeta?action=history;id=MetamathForProgrammers">View other revisions</a> <a class="admin" href="http://planetx.cc.vt.edu/AsteroidMeta?action=admin;id=MetamathForProgrammers">Administration</a></span><span class="time"><br /> Last edited 2008-04-22 18:26 UTC by <a class="author" title="from 66-81-75-115.bayarea.dialup.o1.com" href="ocat">ocat</a> <a class="diff" href="http://planetx.cc.vt.edu/AsteroidMeta?action=browse;diff=1;id=MetamathForProgrammers">(diff)</a></span><form method="get" action="http://planetx.cc.vt.edu/AsteroidMeta" enctype="application/x-www-form-urlencoded">
<p>Search: <input type="text" name="search"  size="20" accesskey="f" /> <input type="submit" name="dosearch" value="Go!" /></p></form></div>
</body>
</html>
