<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html><head><title>AsteroidMeta: metamathGrammarFacilities</title><link type="text/css" rel="stylesheet" href="wiki.css" /><meta name="robots" content="INDEX,NOFOLLOW" /><link rel="alternate" type="application/rss+xml" title="AsteroidMeta" href="index.html@action=rss" /><link rel="alternate" type="application/rss+xml" title="AsteroidMeta: metamathGrammarFacilities" href="http://planetx.cc.vt.edu/AsteroidMeta?action=rss;rcidonly=metamathGrammarFacilities" /></head><body class="http://planetx.cc.vt.edu/AsteroidMeta"><div class="header"><span class="gotobar bar"><a class="local" href="HomePage">HomePage</a> <a class="local" href="RecentChanges">RecentChanges</a> </span><h1><a title="Click to search for references to this page" href="http://planetx.cc.vt.edu/AsteroidMeta?search=metamathGrammarFacilities">metamathGrammarFacilities</a></h1></div><div class="content browse"><p>(Caution: serious ruminating below! This is amateur hour stuff so don't take any wooden nickels!)</p><p>Metamath uses "syntax axioms" to recursively define things such as wff's, classes and terms. It is part of the engineered simplicity of Metamath that these syntax constructors are defined as axioms using the same $a keyword used to define logical axioms, such as those of propositional logic. There are shortcomings to this approach, which can be seen in the present coding of the set.mm database.</p><p>For example, operator overloading of "=" for sets and classes results in an apparent ambiguity when set.mm's syntax axioms are used directly to create a grammar for parsing the symbol sequences making up the formulas of set.mm. The problem isn't necessarily with set.mm but perhaps with the way the grammar is constructed, and the fact that the Metamath specification does not explicitly cover derivation of formal grammars from .mm files. Here is the situation with "=" in set.mm:</p><pre>    $c = wff class set $.
    $v x y A B ph ps $.
    wph $f wff ph $.
    wps $f wff ps $.
    vx $f set x $.
    vy $f set y $.
    cA $f class A $.
    cB $f class B $.
    weq $a wff x = y $.
    cv $a class x $.
    wceq $a wff A = B $.</pre><p>These definitions result in an apparent ambiguity &#x2013; if the grammar is taken directly from the $a statements:</p><pre>    cv says that a set variable can be
    converted to a class expression
 
    
    and so, "x = y" can be parsed to either
 
        "vx vy weq" or
 
        "vx cv vy cv wceq".</pre><p>mmj2 resolves these operator overloading "ambiguities" in the way it builds its  grammar. It attempts to divine the attempt of the author by noting that since weq appears first, an occurrence of "x = y" should be associated with weq and the remaining 3 possibilities should be  associated with wceq. It does this by  using a "combinatorial explosion" of  type conversions on the wceq syntax axiom as it builds its grammar rule table: four grammar rules are built involving weq and wceq:</p><pre>    weq   := set, set 
    wceq1 := class, set 
    wceq2 := set, class
    wceq3 := class, class</pre><p>This technique works satisfactorily for every syntax axiom involving class variables, though it does result in a grammar rule table of neary 500 rules &#x2013; a +300% increase over the original syntax axioms in set.mm.</p><p>So, operator overloading is something that can, perhaps, be satisfactorily defined away with a properly coded grammar that is based on the syntax axioms but contains extra rules that depend on the sequence in the database of the overloading instances.</p><p>There are, however, other desirable syntactic constructions that cannot be so easily defined away. Not without altering expanding the number of grammatical type codes in a Metamath file. Here is a classic example from Schmidt's book on Denotational Semantics (you can google for that):</p><p>""" Ambiguous BNF definitions can often be rewritten  into an unambiguous form, but the price paid is  that the revised definitions contain extra, artificial levels of structure. An unambiguous definition of arithmetic reads:</p><pre>    &lt;expression&gt; ::= &lt;expression&gt; &lt;lowop&gt; &lt;term&gt; | &lt;term&gt;
 
    &lt;term&gt; ::= &lt;term&gt; &lt;highop&gt; &lt;factor&gt; | &lt;factor&gt;
 
    &lt;factor&gt; ::= &lt;numeral&gt; | ( &lt;expression&gt; )
 
    &lt;lowop&gt; ::= + | -
 
    &lt;highop&gt; ::= × | /
 
    &lt;numeral&gt; ::= &lt;digit&gt; | &lt;digit&gt; &lt;numeral&gt;
 
    &lt;digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</pre><p>(The rules for &lt;numeral&gt; and &lt;digit&gt; remain the  same.) This definition solves the ambiguity problem, and now there is only one derivation  tree for 4 × 2 + 1, given in Figure 1.4. The  tree is more complex than the one in Figure 1.2 (or 1.3) and the intuitive structure of the  expression is obscured. Compiler writers further  extend BNF definitions so that fast parsers result. Must we use these modified, complex BNF definitions  when we study semantics? The answer is no.</p><p>We claim that the derivation trees are the real  sentences of a language, and strings of symbols are just abbreviations for the trees. Thus, the string 4 × 2 + 1 is an ambiguous  abbreviation. The original BNF definition of  arithmetic is adequate for specifying the  structure of sentences (trees) of arithmetic, but it is not designed for assigning a unique  derivation tree to a string purporting to be  a sentence. In real life, we use two BNF  definitions: one to determine the derivation  tree that a string abbreviates, and one to  analyze the tree’s structure and determine its semantics. Call these the concrete and  abstract syntax definitions, respectively.</p><p>"""</p><p>The lowop, highop, term and factor types (aka "left hand sides") are synthetic. The user never sees them, just the terminal symbols such as the digits, operators and the resulting expressions. Were we to  implement the above BNF definitions in terms of $a statements we would also be compelled to add variables and variable hypotheses for lowop, highop, term and factor even though these are internal to the process of parsing symbol sequences.</p><p>Creating these additional rules enables the grammar to give precedence to "*" over "+" so that the correct answer to, say, "2 + 3 * 5" can be given without having to  use parentheses.</p><pre>   2 + 3 * 5 = 17 ? or
   2 + 3 * 5 = 30 ? </pre><p>Recent spin-offs from Metamath such as Ghilbert and Bourbaki implement expressions as trees.</p><p>Even so, with the weq/wceq issue, if an author wishes to retain the distinction between weq and wceq, two function names or symbols will be needed; there can be only one function named "=". Thus, it may be that the function names assigned in languages like Ghilbert and Bourbaki should be considered internal, so that users can be presented with the familiar semiotics of "=", regardless of operand types, whenever equality is intended (likewise for other familiar operators&#x2026;)</p><p>And, the fact that languages like Bourbaki and Ghilbert store their formulas as trees does not solve their notational and typesetting problems. Not unless the users are supposed to input sexp's and read Lisp code instead of math and logic formulas! And that means the problem of parsing symbol sequences does not disappear just because <b>internally</b> formulas are stored in trees. So what is becoming apparent now is that there are sound reasons for defining the grammar of a formal language separately from its axioms &#x2013; as Schmidt says, "Call these the concrete and  abstract syntax definitions, respectively."</p><dl class="quote"><dt /><dd>I'm writing up my thoughts on this issue on a separate page entitled <a class="local" href="Ghilbert_syntax_plans">Ghilbert syntax plans</a>. --<a class="local" href="raph">raph</a></dd></dl><p>Still, this may not fully resolve all of our problems so easily! Say, for example there is a function that requires as arguments only <b>proper classes</b> &#x2013; and sets will not do. How then will this be defined in say, Bourbaki whose expressions accept the specified type or any of its sub-types?</p><p>For me that is the unresolved question. Let's look again at axiom "cv" in set.mm:</p><pre>    $( All sets are classes (but not vice-versa!). $)
    cv $a class x $.</pre><p>Is that a "syntax axiom" or an axiom of logic? Both?</p><p>--<a class="local" href="ocat">ocat</a> 23-Oct-2005</p><h2>Proposal</h2><p>by <a class="local" href="marnix">marnix</a> 24-Oct-2005</p><dl class="quote"><dt /><dd>Haven't got the time to read and digest the above in detail, but it is in the same area as a proposal that I came up with this weekend, independently, but also while trying to parse .mm files for Hmm. So I might as well post it here. NOTE: Norm didn't yet have a chance to see this, probably. NOTE 2: My original proposal had "type axiom" instead of "syntax axiom". I like the latter better.</dd><dt /><dd>This proposal seems to be both minimal and in the spirit of Metamath. Is this (i.e., having a .mm file with verified proofs and verified syntax constructions for all non-syntax axioms) really enough to do unambiguous parsing of all assertions?</dd></dl><p>For any axiom that is not a 'syntax axiom' (i.e., for which the initial constant is not the initial contant of an active $f statement), optionally allow a 'syntax construction' $= &#x2026; just before the closing $. For example,</p><pre>  ax-1 $a |- ( ph -&gt; ( ps -&gt; ph ) ) $= wph wps wph wi wi thwff $.</pre><p>This behaves just like a proof, and a Metamath verifier should verify that it really results in the stated axiom.</p><p>But where does the thwff come from? Well, after processing 'wph wps wph wi wi' the stack contains "wff ( ph &#x2192; ( ps &#x2192; ph ) )". Somehow from this, we should be able to conclude that the axiom is syntactically valid, but the axiom has '|-' instead of 'wff'. For this we need a rule saying, "if ps is a wff, then '|- ps' is a syntactically valid (but not necessarily true) assertion". The simplest way to do this, as far as I can see, is to introduce a built-in 'type' $TOP (just choosing a name here which can't be used as a math symbol), and putting in one extra axiom (actually a special syntax axiom):</p><pre>  thwff $a $TOP |- ps $.</pre><p>somewhere after $f wff ps $.</p><p>So then after processing the syntax construction above, the stack contains "$TOP |- ( ph &#x2192; ( ps &#x2192; ph ) )", and this means that the axiom is a syntactically-valid top-level expression.</p><hr /><p>I'm not sure what this additional mechanism buys you. Keep in mind that all terms in Metamath already have two representations: the string of symbols, and the RPN used to push the term onto the stack within a proof. So, the string "( ph &#x2192; ( ps &#x2192; ph ) )" has the RPN representation "wph wps wph wi wi". Using the $a rules, it's always possible to go from the RPN representation to the string. Metamath itself does not offer a mechanism to convert in the other direction.</p><p>The issue is quite a bit trickier when the grammar is ambiguous. For example, in set.mm, "x = y" has the two RPN parses "vx vy weq" and "vx cv vy cv wceq". I've chosen to handle this in my MM &#x2192; GH translation by defining "=" to be the wceq variant and eliminating the weq variant altogether. Another perfectly valid approach would be to define both "=" variants and enforce the distinction between the two literally.</p><p>--<a class="local" href="raph">raph</a></p><hr /><p>re: Marnix --&gt;</p><pre>     Is this (i.e., having a .mm file with verified 
     proofs and verified syntax constructions for 
     all non-syntax axioms) really enough to do 
     unambiguous parsing of all assertions?</pre><p>I do not see that. For two reasons. 1) Merely having <b>a</b> syntax construction (parse) for non-syntax axioms cannot make an ambiguous grammar unambiguous, and 2) Metamath does not require that provable assertions be parseable (substract new axiom "wxy" from miu.mm and see that the proofs still hold &#x2013; but add it back and suddendly the grammar is ambiguous!)</p><p>--<a class="local" href="ocat">ocat</a> 24-Oct-2005</p><hr /><p>Over the last days I've been thinking about the above two replies, and most of all, I've been coding today just to see what my thoughts would look like in an actual implementation. What I've been writing (and what I'll probably put in Hmm) is a tool to find all possible parse trees for non-syntax axioms. And what I've done on paper (and should be simple to code up) is to find the parse trees that are implied by the proofs of $p statements.</p><p>Let me respond point by point:</p><ul><li><a class="local" href="ocat">ocat</a>: "&#x2026;cannot make an ambiguous grammar unambiguous"; <a class="local" href="raph">raph</a>: "I'm not sure what this additional mechanism buys you." My intention here is not to make an ambiguous grammar unambiguous, but to make sure that Metamath-related software can work with parse trees instead of just token sequences. And with as little guessing or database-specific annotations as possible. The explicit 'syntax construction' in RPN format for non-syntax $a statements seems to do the trick. For each assertion, this points the Metamath-related software (Hmm in this case) to exactly one of the possible RPN parses: the one that the user prefers. So this is a matter of guiding Metamath-related software.</li><li><a class="local" href="ocat">ocat</a>: "Metamath does not require that provable assertions be parseable" Agreed, and it's OK to keep things that way. However, in the majority cases (set.mm and ql.mm are of course the best examples) this <i>is</i> the intention of the user. So in my view it is not so strange to have a mechanism to specify and automatically check this intention. And as I said, this mechanism would be <b>optional</b>. And it is only required for (1) $a statements that are (2) non-syntax axioms, and for which (3) multiple RPN parses exist. I don't have numbers yet, but my experiments suggest that this is a small number of statements.</li><li><a class="local" href="raph">raph</a>: "Metamath itself does not offer a mechanism to convert in the other direction." My proposal is exactly about such a mechanism: let the user provide <b>an</b> RPN representation for every non-syntax $a statement. (If the grammar is ambiguous, the user has a choice, and in this way s/he can indicate, e.g., which version of '=' was intended.) From these RPN representations, it is then possible to use the proofs of the $p statements to find <b>an</b> RPN representation for every $p statement. (Again, if the grammar is ambiguous, there will be multiple RPN parses for the $p statement, but the proof allows exactly one of these parses.)</li><li><a class="local" href="raph">raph</a>: "&#x2026;has the two RPN parses "vx vy weq" and "vx cv vy cv wceq"." Yes, the choice is arbitrary because of the ambiguity in the grammar. Hmm will probably choose the shortest one available, and choose an arbitrary one if multiple shortest parses exist.</li></ul><p>(I don't have time now to explain why the proof of a $p statement --specifically the RPN parse of the assertion used in the top-level/last proof step&#x2013; determines the RPN parse of the $p statement.)</p><p>Hope this makes things clearer&#x2026;</p><p>Next up in Hmm (but I'm not promising a date): a tool that prints all possible RPN parses for each assertion in a database.</p><p>--<a class="local" href="marnix">marnix</a></p><p>Yes. I get it now. Thanks for the clarification. I'm not sure I have a warm, fuzzy feeling about the proposal, but I do see what it's trying to do.</p><p>/"all possible RPN parses"/ &#x2013; doesn't that make the hair stand up on the back of your neck when you think about the exponential blowup?</p><p>--<a class="local" href="raph">raph</a></p><p>One point to consider, based on the example of miu.mm &#x2013; which is highly ambiguous with syntax axiom wxy's presence &#x2013; is that the $e statements can effectively introduce syntax. How else could the proofs in miu.mm work in the absence of wxy? A $e is like a syntax axiom, in some respects, if it is not parseable.</p><p>Regarding the job of producing all possible RPN parses, I settled on the Earley Parse algorithm in mmj2 because it can handle ambiguous grammars. The default maximum number of parse trees returned in "extended" editing mode is 2, but a constant parameter in mmj.verify.GrammarConstants<a class="edit" title="Click to edit this page" href="http://planetx.cc.vt.edu/AsteroidMeta?action=edit;id=GrammarConstants">?</a>.java allows the number to be set to an arbitrary level, like 100. The Earley Parse is fairly speedy even with "extended" ambiguity checking, unlike the Bottom Up parse algorithm which can easily spend an hour or more working on a single formula :)</p><p>--<a class="local" href="ocat">ocat</a></p><p>Instead of</p><pre>  thwff $a $TOP |- ps $.
  ax-1 $a |- ( ph -&gt; ( ps -&gt; ph ) ) $= wph wps wph wi wi thwff $.</pre><p>could you use the following?</p><pre>  ax-1 $a |- ( ph -&gt; ( ps -&gt; ph ) ) $.
  ax-1-wff $p wff ( ph -&gt; ( ps -&gt; ph ) ) $= wph wps wph wi wi $.</pre><p>This is compatible with the current spec and existing proof verifiers. Of course, your own program would be needed to check that ax-1-wff exists and matches ax-1, which current verifiers don't do.</p><p>Perhaps a better way - at least until your proposal becomes popular - is to have your axiom syntax proofs in a separate file, automatically generated and regenerated as needed, with a tool derived, say, from  mmj2's parser. This way there would be no danger of the syntax proofs getting out of sync with the axioms, as might happen if they are embedded in the source (since current verifiers do not enforce them).</p><p>--<a class="local" href="norm">norm</a> 28-Oct-2005</p></div><div class="footer"><hr /><span class="gotobar bar"><a class="local" href="HomePage">HomePage</a> <a class="local" href="RecentChanges">RecentChanges</a> </span><span class="edit bar"><br /> <a class="edit" accesskey="e" title="Click to edit this page" href="http://planetx.cc.vt.edu/AsteroidMeta?action=edit;id=metamathGrammarFacilities">Edit this page</a> <a class="history" href="http://planetx.cc.vt.edu/AsteroidMeta?action=history;id=metamathGrammarFacilities">View other revisions</a> <a class="admin" href="http://planetx.cc.vt.edu/AsteroidMeta?action=admin;id=metamathGrammarFacilities">Administration</a></span><span class="time"><br /> Last edited 2005-10-28 18:20 UTC by <a class="author" title="from 209-6-249-153.c3-0.lex-ubr2.sbo-lex.ma.cable.rcn.com" href="norm">norm</a> <a class="diff" href="http://planetx.cc.vt.edu/AsteroidMeta?action=browse;diff=1;id=metamathGrammarFacilities">(diff)</a></span><form method="get" action="http://planetx.cc.vt.edu/AsteroidMeta" enctype="application/x-www-form-urlencoded">
<p>Search: <input type="text" name="search"  size="20" accesskey="f" /> <input type="submit" name="dosearch" value="Go!" /></p></form></div>
</body>
</html>
