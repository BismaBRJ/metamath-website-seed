<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html><head><title>AsteroidMeta: GhilbertVsMetamathPart1</title><link type="text/css" rel="stylesheet" href="wiki.css" /><meta name="robots" content="INDEX,NOFOLLOW" /><link rel="alternate" type="application/rss+xml" title="AsteroidMeta" href="index.html@action=rss" /><link rel="alternate" type="application/rss+xml" title="AsteroidMeta: GhilbertVsMetamathPart1" href="http://planetx.cc.vt.edu/AsteroidMeta?action=rss;rcidonly=GhilbertVsMetamathPart1" /></head><body class="http://planetx.cc.vt.edu/AsteroidMeta"><div class="header"><span class="gotobar bar"><a class="local" href="HomePage">HomePage</a> <a class="local" href="RecentChanges">RecentChanges</a> </span><h1><a title="Click to search for references to this page" href="http://planetx.cc.vt.edu/AsteroidMeta?search=GhilbertVsMetamathPart1">GhilbertVsMetamathPart1</a></h1></div><div class="content browse"><p>The Ghilbert design, though somewhat sketchy, is interesting both as it relates to Metamath, and as a fount of ideas for <a class="local" href="PlanetMath">PlanetMath</a>'s HDM project.</p><p>What follows is a rough, unproven draft copy with only cursory review by the Ghilbert designer. Conclusions drawn may be erroneous. The objective is to work through the design document: "Design of the Ghilbert proof format", dated 21 Oct 2003 from www.ghilbert.org.</p><p>This is only Part I. <a class="local" href="GhilbertVsMetamathPart2"> Part II</a> is now complete, but parts III and IV may never be written. A lot depends on fate :) And frankly, I like Metamath. I like the idea of students and amateur, non- academics being able to create their own quirky, crufty, ambiguous grammars, making grand mistakes and learning from them. Metamath really just needs a GUI to make it more approachable. Even just a more powerful Proof Assistant might do the job!</p><p>But maybe Ghilbert is the way to go? After all these years, will we get rid of our faithful pickup truck with 200,000 miles that still always starts the first time, trading it  for a fancy new sports car? Hmmm.</p><p><b>Metamath vs. Ghilbert - PART I</b></p><p>*1. SYNTAX*</p><p>Ghilbert statements are written using a command name followed by an "sexp" (s-expression). Ghilbert tokens are 7-bit ASCII codes between 33 and 126 inclusive, separated by whitespace. (Note: the Ghilbert design document states that commands are written entirely on a single line, but that is out of date).</p><p>Metamath statements are keyword based, can range across several lines, and are also composed of 7-bit ASCII codes.</p><pre>    Ghilbert
    ========
    # comment: A blank line is also considered a comment:
    
    stmt ( ax-1 ( ) ( ) ( -&gt; ph ( -&gt; ps ph ) ) )
 
    Metamath
    ========
    $( comment: blah-blah.
       A Metamath comment can be embedded between
       any two tokens, except inside a comment. $)
    ax-1 $a |- ( ph -&gt; ( ps -&gt; ph ) ) $. </pre><p>NOTE: From the standpoint of readability, it is an essential feature that Ghilbert statements are allowed to be broken up and extend across multiple lines, hence this change in the Ghilbert design. Embedded comments are nice too. Maximum line lengths and line delimiters may vary from one operating system to the next, so an argument can be made that line terminators should not be a feature of the syntax.</p><hr /><p>*2. GRAMMATICAL TYPES*</p><p>Grammatical Type Codes are explicitly declared in Ghilbert using the "kind" statement. Each Kind must be unique within a file's Kind Namespace, which is used to validate Kinds used on other Ghilbert statements.</p><p>(Note from <a class="local" href="raph">raph</a> - I am making a distinction between "type" and "kind", which is fairly subtle. The concept of "kind" is entirely syntactic, and every term and variable has its kind immediately apparent. The concept of "type" is more relevant in typed axiomatic frameworks such as HOL than in essentially untyped axiomatic frameworks such as ZFC set theory and second order arithmetic. The fact that a value has a particular type is a wff. For example, all values in my HOL axiomatization have kind "val" but may have different types. The constant "0" could have type "nat", for example, meaning that (: (0) (nat)) is a theorem, while "+" has type "nat * nat &#x2192; nat". Both "0" and "+" have kind "val". In any given universe, the number of kinds will be small (a handful), but in a typed logic such as HOL the space of types is rich and large.)</p><p>[Reply by <a class="local" href="ocat">ocat</a> &#x2013; I think I understand. What <b>I</b> am referring to as a "Type" or "Grammatical Type" (I changed the heading above), is what Ghilbert refers to as a "kind", and that you chose the term "kind" so that you could avoid muddying the semantic waters of "mathematical types" in the object languages to be expressed in Ghilbert versus the syntactic/grammatical <b>kinds</b> used to define those items in Ghilbert source statements. So&#x2026;henceforth, the term "type" will be avoided like the plague unless we're talking about HOL or category theory or whatever&#x2026;it is too late to go back and change mmj2 now though :) So in that context I will try to use "grammatical type" or "Type Code" in some cases, and avoid more confusion.]</p><hr /><p>In Metamath a "kind" is merely a declared constant that appears in the first symbol position of a formula. There is no Metamath restriction on using that constant in other symbol positions as a plain old constant. Though mmj2's Grammar checker does include a "dual-use" Grammatical Type/constant prohibition, that prohibition appears to be unnecessary in Ghilbert because of the syntax of Ghilbert's "term" statement.</p><pre>    Ghilbert
    ========
    kind ( wff )
    
    Metamath
    ========
    $c wff $. </pre><p>(Note from <a class="local" href="raph">raph</a> - see also Metamath's restrictions on the $f statement. While you could overload a constant as both a "kind" and for other uses, an $f statement accepts only the former use. The "var" statement in Ghilbert corresponds very closely to $f in Metamath, so the concept of "kind" may be more similar than immediately apparent.)</p><p>[Replay by <a class="local" href="ocat">ocat</a> &#x2013; mmj2 doesn't handle meta-metamath statements or grammars such as "$a |- |- x &#x2192; y $." or "$p |- ph &#x2192; wff", where "|-" and "wff" are used as <b>grammatical</b> Types. The mmj2 restriction has to do with the parsing algorithm more than anything else &#x2013; Ghilbert makes the issue disappear with "kind" and "var", so bravo! Yay.]</p><hr /><p>*3. USER TERMS/NOTATIONS/GRAMMAR RULES*</p><p>Ghilbert defines grammatical "terms" using the "term" statement. It makes no distinction between a "wff" and a "term", they are both "terms".</p><p>The "term" statement defines a grammatical replacement rule for a "kind". While it differs from the Metamath "$a" command's use as a grammar builder in several important ways but is very similar overall:</p><p>- A Ghilbert term is uniquely identified by its Term Name which is unique within the file's term/variable joint namespace. Interestingly, a Ghilbert term does not have a "label". Term name serves as the label in proof steps in addition to its normal use in formulas (sexp's).</p><p>- Another difference between Ghilbert and Metamath notation definitions is that Ghilbert doesn't bother with variable names in term definitions, and simply specifies a sequence of Kinds. This tidies up a loose end in Metamath, which does not explicitly require its syntax axiom variables to have different names even though it relies upon that condition for ordering its proof work stack (mmj2 does check for different variable names in syntax axioms).</p><p>- "arity" can be 0, 1, &#x2026;, n in Ghilbert as in Metamath, but Null terms are (apparently) not supported in Ghilbert. And, it appears that operator overloading is unsupported (the list of kinds associated with a unique term name is fixed). Thus, automatic Ghilbert/Metamath conversions will not always be perfect because Metamath supports a larger class of grammars.</p><p>(Note from <a class="local" href="raph">raph</a> - any overloading or variable-arity Metamath grammar items will need to be converted into distinct Ghilbert term names. The class of grammars is exactly the same, it's just that in Ghilbert the disambiguation is always explicit in the term names, rather than implicit.)</p><p>[Reply by <a class="local" href="ocat">ocat</a> - Metamath allows ambiguous grammars, which I don't think is true for Ghilbert.]</p><pre>    Ghilbert
    ========
    # a 0-ary term, term name = "E"
    term ( class ( E ) )
 
    # 1-ary term, term name = "-."
    term ( wff ( -. wff ) )
     
    # 2-ary term, term name "-&gt;" 
    term ( wff ( -&gt; wff wff ) )
     
    # Type conversion, from kind "set" to "class"
    term ( class ( cv set ) )
 
    # nulls permitted error?! yes, no term name.
    term ( wff ( ) ) 
     
    # operator overloading error? yes, dup term name.
    term ( N ( + N N ) )
    term ( I ( + I I ) )
        
    Metamath
    ========
    $( 0-ary -- AKA "named, typed-constant" -- "E" $)
    cE $a class E $. 
 
    $( 1-ary, label = wn $)
    wn $a wff -. ph $. 
 
    $( 2-ary, label = "wi" $)
    wi $a wff ( ph -&gt; ps ) $.
 
    $( Type conversion from type "set" to class
       where "x" is a variable with type "set": $)
    cv $a class x $.
     
    $( operator overloading in Metamath $)
    plusN $a N ( x + y ) $.
    plusC $a I ( i + j ) $.
     
    $( nulls permitted declaration ok in Metamath$)
    wNull $a wff $.</pre><p>(Note from <a class="local" href="raph">raph</a> - Metamath permits waaaay too much stuff. It relies entirely on the discipline and good sense of the theorem author to avoid ambiguity, inconsistent definitions, etc. The pitfalls are not always obvious. For example, the notation $a class A ! $. for factorial would create a grammatical ambiguity, which is why the notation ( ! ` A ) is used instead.)</p><p>[Reply by <a class="local" href="ocat">ocat</a> - I have documented numerous ambiguous grammars (see mmj2.zip) and hope to write code in mmj2 to detect those. I think Ghilbert is wise to steer clear of ambiguity, right from the start, no matter how interesting and useful ambiguities may be in certain contexts (politicians wouldn't be able to talk if we disallowed them ambiguity.] </p><hr /><p>*4. VARIABLES*</p><p>Variables are declared using the "var" statement in Ghilbert, which is like Metamath's "$v" statement except that it specifies a Kind in addition to the variable name.</p><p>The "var" statement is a like combination of Metamath's  $v and $f statements, but unlike Metamath:</p><p>- a variable's Type/Kind is fixed.</p><p>- a variable is always "active" (in scope) within the file in which it is defined (from the standpoint of grammatical parsing, this difference <b>really</b> simplifies things!)</p><p>- variable name is (must be) unique within the file's term/variable joint namespace.</p><p>Another interesting difference between Ghilbert and Metamath is that there is no such thing as a variable hypothesis, or its label. A variable's name is used to refer to the variable both in subsequent formulas <b>and</b> in proofs.</p><pre>    Ghilbert
    ========
    var ( wff ph ph ) # multiple vars in single var are ok
     
    Metamath
    ========
    $v ph ps $. $( multiple vars in single $v are ok $)
    wph $f wff ph $.
    wps $f wff ps $.
 </pre><hr /><p>*5. The "Truth" Type Code*</p><p>Metamath employs a Type Code on every formula, including Logical Hypotheses and Logical Assertions, Axiomatic and Provable. Typically, the Type Code used is "|-" Type Code, which when applied to a "wff"-ish expression (a logical expression), is construed to mean "It is provable that&#x2026;" or "It is true that&#x2026;".</p><p>The "|-" Type Code distinguishes "logical" statements from notation statements ("term" statements in Ghilbert terminlogy.)</p><p>In Ghilbert the "|-" Type Code is <b>implied</b> by the location of a formula. In the Ghilbert Proof Verifier (gh_verify.py), as logical expressions (logical hypotheses, plus "stat", "ax" and "thm") are pushed onto the stack, type code "|-" (which is hard-coded) is prefixed to the expression. Thus, "( &#x2192; ph ph )" is loaded onto the stack as "|- ( &#x2192; ph ps )".</p><p>While it is true that the Ghilbert Proof Verifier does not double-check to ensure that "|-" is applied only to "wff"-ish expressions, neither does Metamath.exe. (Bluntly, the user is free to code non-sensical logic statements, such as "It is provable that DOG".)</p><p>[In mmj2 the user specifies the specific logic Type Codes corresponding to "|-" and "wff" so that grammatical parsing can proceed rigorously; Ghilbert's formulas are  pre-parsed sexp's and the question does not arise.]</p><p>(Note from <a class="local" href="raph">raph</a> - I consider |- to be an internal artifact of the proof language, not a fundamental property. Metamath uses the same concept (represented by the use of $a) for both syntactic well-formedness and logical provability, hence the need to distinguish the two. In Ghilbert, there are two different mechanisms to express these two concepts. It is true that gh_verify uses the string "|-" as a pseudo kind name, but that is strictly an implementation artifact and could easily be removed.)</p><p>{Note from <a class="local" href="ocat">ocat</a> &#x2013; "|-" is an artifact, of course, but its genesis is relevant, especially with respect to Ghilbert's decision to treat wff's and terms as "term"s. Metamath makes no distinction &#x2013; is agnostic &#x2013; about symbols, whether they are logical symbols or "functions". The <b>kind</b> (or Grammatical Type Code" of a formula in a theorem, axiom, or logical  hypothesis) ought to be "wff" (or else the wff-like <b>kind</b> that maps to "|-" or the equivalent, where both "wff" and "|-" are arbitrary, perhaps set by the user.) In other words, it would not make sense to have a "theorem", "3 + 5", because  "3 + 5" is not a logical assertion. Enderton makes the distinction  in "A Mathematical Introduction to Logic" in 2.1, p. 72: "An expression is any finite sequence of symbols. Of course most expressions are nonsensical, but there are certain  interesting expressions: the terms and the wffs." The reason "|-" is handy on the proof stack is that it establishes the provenance of an expression, and acts as a guarantee that the prover is not (incorrectly) substituting a grammatical production where an axiom, theorem or logical hypothesis is required.} </p><hr /><p>*6. Begin/End Scope Statements*</p><p>Metamath's Begin Scope statement, "${" and End Scope statement, "$}" have no equivalent in Ghilbert.</p><p>In Ghilbert, every Assertion (via "stat" or "thm") has its own personalized lists, possibly empty, of Disjoint Variable Restrictions and Logical Hypotheses. This simplifies things quite a bit, especially since every Ghilbert variable is defined in a global namespace <b>with</b> an associated Kind, and there is no need to re-declare variable hypotheses in an Assertion's Mandatory or Optional Frames.</p><p>Also, since Ghilbert has "modules" (described later), there is no urgent need to use scope declarations so that the variable namespace can be reused within a file.</p><p>In practice, for example in Metamath's set.mm, 99% of variables are defined globally <b>anyway</b>, which actually makes the file more readable and consistent (no guessing about what "x" means, for example.) And, guesstimating again, 99% of the time in set.mm, a scope is defined for an Assertion if and only if the Assertion has Disjoint Variable restrictions and/or Logical Hypotheses. So taking away the Begin/End Scope statements appears to be an elegant simplification.</p><p>Here is a prototypical Metamath scope from set.mm (expanded proof format version, "expset.mm") followed by the same mathematical object expressed in Ghilbert:</p><pre>    Metamath
    ========
    ${ 
        $d x ps $.
        a4b.1 $e |- ( x = y -&gt; ( ph -&gt; ps ) ) $.
        $( A weaker version of ~ a4a . $)
        a4b $p |- ( A. x ph -&gt; ps ) $=
          wph wps vx vy wps vx ax-17 a4b.1 a4a $.
          $( [5-Aug-93] $)
    $}
 
    Ghilbert
    ========
    thm (a4b ((ps x)) 
      ((a4b.1 (-&gt; (= (cv x) (cv y)) (-&gt; ph ps))))
      (-&gt; (A. x ph) ps)
      (ps x ax-17 a4b.1 a4a
    ))
 Notes:</pre><p>a) As you can see, Ghilbert does away with scope blocks and puts the $d's and $e's inside the Assertion!</p><p>b) The Ghilbert example's expressions "cv x" and "cv y" invoke type conversion from "set" to "class" because Ghilbert does not allow operator overloading &#x2013; the term "= class class" is defined, but "= set set" is not.</p><p>c) The Ghilbert proof is much shorter. Curious? The mystery will be explained later!</p><p>--<a class="local" href="ocat">ocat</a></p><p>Continue to <a class="local" href="GhilbertVsMetamathPart2">GhilbertVsMetamathPart2</a></p></div><div class="footer"><hr /><span class="gotobar bar"><a class="local" href="HomePage">HomePage</a> <a class="local" href="RecentChanges">RecentChanges</a> </span><span class="edit bar"><br /> <a class="edit" accesskey="e" title="Click to edit this page" href="http://planetx.cc.vt.edu/AsteroidMeta?action=edit;id=GhilbertVsMetamathPart1">Edit this page</a> <a class="history" href="http://planetx.cc.vt.edu/AsteroidMeta?action=history;id=GhilbertVsMetamathPart1">View other revisions</a> <a class="admin" href="http://planetx.cc.vt.edu/AsteroidMeta?action=admin;id=GhilbertVsMetamathPart1">Administration</a></span><span class="time"><br /> Last edited 2005-09-17 18:01 UTC by <a class="author" title="from dialup-4.243.149.242.Dial1.SanFrancisco1.Level3.net" href="ocat">ocat</a> <a class="diff" href="http://planetx.cc.vt.edu/AsteroidMeta?action=browse;diff=1;id=GhilbertVsMetamathPart1">(diff)</a></span><form method="get" action="http://planetx.cc.vt.edu/AsteroidMeta" enctype="application/x-www-form-urlencoded">
<p>Search: <input type="text" name="search"  size="20" accesskey="f" /> <input type="submit" name="dosearch" value="Go!" /></p></form></div>
</body>
</html>
