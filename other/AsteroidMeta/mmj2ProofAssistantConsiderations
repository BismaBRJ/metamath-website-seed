<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html><head><title>AsteroidMeta: mmj2ProofAssistantConsiderations</title><link type="text/css" rel="stylesheet" href="wiki.css" /><meta name="robots" content="INDEX,NOFOLLOW" /><link rel="alternate" type="application/rss+xml" title="AsteroidMeta" href="index.html@action=rss" /><link rel="alternate" type="application/rss+xml" title="AsteroidMeta: mmj2ProofAssistantConsiderations" href="http://planetx.cc.vt.edu/AsteroidMeta?action=rss;rcidonly=mmj2ProofAssistantConsiderations" /></head><body class="http://planetx.cc.vt.edu/AsteroidMeta"><div class="header"><span class="gotobar bar"><a class="local" href="HomePage">HomePage</a> <a class="local" href="RecentChanges">RecentChanges</a> </span><h1><a title="Click to search for references to this page" href="http://planetx.cc.vt.edu/AsteroidMeta?search=mmj2ProofAssistantConsiderations">mmj2ProofAssistantConsiderations</a></h1></div><div class="content browse"><p>A few untutored, possibly false-to-fact thoughts about the hypothetical new mmj2 Proof Assistant, planned for completion by September 2006.</p><hr /><p>Of interest:</p><p>Dick Grune and Ceriel J.H. Jacobs, "Parsing Techniques - A Practical Guide"</p><p><a class="url" href="http://www.cs.vu.nl/~dick/PTAPG.html">http://www.cs.vu.nl/~dick/PTAPG.html</a></p><p>See pages 60-61 "2.10 A METAPHORICAL COMPARISON OF GRAMMAR TYPES"</p><p>"The set of all Pascal programs that would terminate in finite time when run with a given input can be generated by an unrestricted phrase structure grammar. Such a grammar would, however, be very complicated, even in van Wijngaarden form, since it would incorporate detailed descriptions of the Pascal library routines and the Pascal run-time system.</p><p>The set of all Pascal programs that solve a given problem (for instance, play  chess) cannot be generated by a grammar (although the description of the set is finite)."</p><hr /><p>A Metamath proof is in actuality, a program, that when fed into the stack-based, push-down automaton Proof Verification Engine, generates the sequence of symbols that is the object of the proof.</p><p>Given that the final label in a Metamath proof <b>must</b> yield a single formula on the Proof Work Stack that matches the $p statement's formula, it is known in advance of Proof Verification exactly what must be on the Proof Work Stack after the next to last label is processed by the Proof Verification Engine: "4. If the label refers to an assertion with hypotheses, a (unique) substitution must exist that, when made to the mandatory hypotheses of the referenced assertion, causes them to match the most recent entries of the Proof Work Stack." and "6. The same substitutions are made to the referenced assertion, and the result is pushed onto the Proof Work Stack." (from C:/mmj2/doc/mmjProofVerification.html in mmj2.zip).</p><p>We also know that if the grammar is unambiguous, the final label must refer to a formula whose grammatical parse tree root node matches the parse tree root node of the formula being proved &#x2013; OR that the formula can provide such a root node via substitution into a variable hypothesis (ex. if the statement being proved is of the form "a &#x2192; b" then either the final label's formula must be the form "a &#x2192; b" or of the form "a".) This assumes that every statement can be grammatically parsed, which is <b>not</b> a requirement of the Metamath specification  (see miu.mm!)</p><p>Now, unless the "proof" is a trivial one-liner that "proves" its hypothesis, the final statement label must refer to an Assertion, it cannot refer to an Hypothesis. Thus, deriving the non-trivial proof of Statement "X" using backwards reasoning means using <b>abductive</b> reasoning (or enlightened guessing) to figure out which label is the final label. Once that is determined, what remains is a simple exercise in deriving the necessary stack contents that will await the final proof step. And, since we can generate the final step of <b>a</b> proof, generating these earlier stack entries is also doable :) Ha.</p><p>Last year Norm Megill applied his "improve" command to the contents of set.mm, and surprise(!), Metamath.exe generated  shorter proofs than the hand-coded entries for quite a few  of the theorems! But, if memory serves, those were all in  the propositional logic section of the set.mm database.</p><p>As a practical matter, generating an arbitrary missing proof step of an arbitrary proof involving predicate logic is not doable (the program might get lucky, but mathematically, the number of possible RPN label strings to try out is excessive.)</p><p>What does seem reasonable is saving the person doing the proof work the trouble of having to memorize the many thousands of Metamath labels (that's just in set.mm). If the Proof Assistant could handle a column of formulas with step justifications consisting of only the previous step numbers to be used as hypotheses for the current step's assertion (and nothing if the step is an hypothesis), then the Proof Assistant ought to be able to figure out which label is required &#x2013; and how to arrange this information into an RPN sequence of labels constituting a valid proof step (a Metamath proof is like assembler, with lots of syntax and variable hypothesis labels interspersed with the "real" labels, the logical hypotheses and assertions.)</p><p>The reasoning behind this is that a proof can be represented as a tree with 'n' children, where n is the number of hypotheses in the statement's mandatory frame (variable and logical hypotheses). Each child node is a sub-proof, with recursive considerations that apply. The structure of a Metamath proof tree is identical to the structure of a Metamath statement parse tree, except that the proof is a parse using some <b>extremely</b> high order grammar that generates grammatically correct and true statements in the logical system being studied :)</p><p>--<a class="local" href="ocat">ocat</a></p><p><a class="local" href="mmj2ProofAssistantUnification">mmj2ProofAssistantUnification</a> draft! --<a class="local" href="ocat">ocat</a> 8-Nov-2005</p></div><div class="footer"><hr /><span class="gotobar bar"><a class="local" href="HomePage">HomePage</a> <a class="local" href="RecentChanges">RecentChanges</a> </span><span class="edit bar"><br /> <a class="edit" accesskey="e" title="Click to edit this page" href="http://planetx.cc.vt.edu/AsteroidMeta?action=edit;id=mmj2ProofAssistantConsiderations">Edit this page</a> <a class="history" href="http://planetx.cc.vt.edu/AsteroidMeta?action=history;id=mmj2ProofAssistantConsiderations">View other revisions</a> <a class="admin" href="http://planetx.cc.vt.edu/AsteroidMeta?action=admin;id=mmj2ProofAssistantConsiderations">Administration</a></span><span class="time"><br /> Last edited 2005-11-09 01:42 UTC by <a class="author" title="from dialup-4.243.149.103.Dial1.SanFrancisco1.Level3.net" href="ocat">ocat</a> <a class="diff" href="http://planetx.cc.vt.edu/AsteroidMeta?action=browse;diff=1;id=mmj2ProofAssistantConsiderations">(diff)</a></span><form method="get" action="http://planetx.cc.vt.edu/AsteroidMeta" enctype="application/x-www-form-urlencoded">
<p>Search: <input type="text" name="search"  size="20" accesskey="f" /> <input type="submit" name="dosearch" value="Go!" /></p></form></div>
</body>
</html>
