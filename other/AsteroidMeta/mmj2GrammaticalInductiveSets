<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html><head><title>AsteroidMeta: mmj2GrammaticalInductiveSets</title><link type="text/css" rel="stylesheet" href="wiki.css" /><meta name="robots" content="INDEX,NOFOLLOW" /><link rel="alternate" type="application/rss+xml" title="AsteroidMeta" href="index.html@action=rss" /><link rel="alternate" type="application/rss+xml" title="AsteroidMeta: mmj2GrammaticalInductiveSets" href="http://planetx.cc.vt.edu/AsteroidMeta?action=rss;rcidonly=mmj2GrammaticalInductiveSets" /></head><body class="http://planetx.cc.vt.edu/AsteroidMeta"><div class="header"><span class="gotobar bar"><a class="local" href="HomePage">HomePage</a> <a class="local" href="RecentChanges">RecentChanges</a> </span><h1><a title="Click to search for references to this page" href="http://planetx.cc.vt.edu/AsteroidMeta?search=mmj2GrammaticalInductiveSets">mmj2GrammaticalInductiveSets</a></h1></div><div class="content browse"><p>Some thinking, preliminary to continuing the work on detecting Ambiguity in mmj2. --<a class="local" href="ocat">ocat</a> 10-Oct-2005</p><hr /><p>Enderton's "A Mathematical Introduction to Logic" (1972, Academic Press) details a method for constucting the subset ("C") of the set of all possible symbol sequences in his propositional logic language (see pages 22 and 23 in Chapter 1.2, Induction and Recursion.)</p><p>Applying this to an arbitrary grammar generated from a Metamath .mm database such as set.mm requires a change to Enderton's scheme. In set.mm wff and class are defined recursively in terms of each other, and his grammar rules accept untyped symbol sequences (expressions).</p><p>To make the set-building scheme work one could specify that the arguments to the grammar rules be "typed", but that would require a parse function to determine the type of an arbitrary symbol sequence; we have that (in mmj2 &#x2013; with certain restrictions), but the mathematical definition would be cluttered.</p><p>Instead, the method from Metamath's proof verification engine is used. Substitution of an expression for a variable in Metamath's proof engine is allowed only if the first symbol of each formula matches &#x2013; the first symbol is a grammatical type code that Metamath prepends to every expression.</p><p>We stipulate that the grammar rule arguments contain a prepended grammatical Type Code that matches the grammar rule's argument type &#x2013; or else the rule outputs a null symbol sequence! Creating a null symbol sequence as part of the definition allows us to say that the set of formulas given by the grammar rules is closed under the set U, the set C and the initial starter set ("B") if we include the null symbol sequence everywhere.</p><p>And we stipulate that the output from a grammar rule is not an expression such as "( wff &#x2192; wff )" but a complete <b>formula</b> with prepended Type Code, like this: "wff ( wff &#x2192; wff )". This establishes that the output of each grammar rule is also grammatically typed, and eliminates spurious output (such as would otherwise occur when a class expression is fed into a naive grammar rule expecting a wff.) Output wff's are thus fed into subsequent operations expecting wff's and any attempt to feed a class argument with a wff generates only an output of null!</p><p>Endertons "Induction Principle" theorem is as follows: Assume that C is the set generated from B by the functions in F. If S is a subset of C which includes B and is closed under the functions of F, then S = C.</p><p>In our situation we add the null symbol sequence to U, and B. And specify that instead of populating B with the sentence symbols of the language, that B contains &#x2013; in addition to null &#x2013; either the grammar rule formulas themselves, or the grammatical Type Codes, prepended with themselves (like "wff wff", thus treating "wff" as if it were the name of a variable.) This generates a correct C, except that C also contains the null formula, which may need to be accounted for in subsequent work.</p><p>In Schmidt's "Denotational Semantics" book, [ <a class="url" href="http://www.cis.ksu.edu/~schmidt/text/densem.html">http://www.cis.ksu.edu/~schmidt/text/densem.html</a> ] section 1.2 "Mathematical and Structural Induction" associated information about grammar rules that are defined in mutually recursive form. Schmidt also provides a very helpful theorem using structural induction on trees. Step 1, is of course, being able to actually construct the set/tree under consideration&#x2026;And next, to show that the output of the grammar building operations generate unambiguous output (or else follow-on proofs involving thee inductive sets and trees/ expressions will not be valid!)</p><p>That's how I see things anyway (but IANAM :)</p><hr /><p>Maybe its just my head spinning, but it seems like Ray and I were just talking about something very similar, except, we had it in terms of "theorems" (instead of C) and "induction rules" (instead of F). B &amp; S were only figured more vaguely, at least for me (Ray was leading the dicussion and I was following along as best I could). We then moved on to talk about "predicates" implementing the induction rules (and transposing into a meta-language). This idea of using grammar rules, however, is new to me. Maybe I'll get the picture eventually, with some help. --<a class="local" href="jcorneli">jcorneli</a></p><p>The commonly used technical term for what I call "grammar rules" is "grammar productions", often in conjunction with  "BNF". In mmj2 additional information is stored with each rule/production, so my ex-post facto self-justications for making my own terminology seems sound, to me :)</p><p>Enderton goes to great lengths to establish a sound foundation for his specific little language, which itself is designed to be unambiguous, easy to parse&#x2026;and easy to prove that it is those things :) With Metamath the situation is more challenging. As Norm would say, Metamath is not just logic agnostic, it is grammar agnostic! The user can define any language she wants that will fit into the Context Free Grammar model (or below on the Chomsky hierarchy). What is most appealing to me is that a Metamath database user-language is self defining. One could envision encoding a .mm file such as set.mm and beaming it to an alien race without accompanying documentation. --<a class="local" href="ocat">ocat</a></p><p>OTOH, with just a bit more documentation, something like <a class="local" href="Natural_deduction_based_metamath_system">Natural deduction based metamath system</a> could probably become much more self-explanatory, and could be something like a tutorial in the system. --<a class="local" href="jcorneli">jcorneli</a></p></div><div class="footer"><hr /><span class="gotobar bar"><a class="local" href="HomePage">HomePage</a> <a class="local" href="RecentChanges">RecentChanges</a> </span><span class="edit bar"><br /> <a class="edit" accesskey="e" title="Click to edit this page" href="http://planetx.cc.vt.edu/AsteroidMeta?action=edit;id=mmj2GrammaticalInductiveSets">Edit this page</a> <a class="history" href="http://planetx.cc.vt.edu/AsteroidMeta?action=history;id=mmj2GrammaticalInductiveSets">View other revisions</a> <a class="admin" href="http://planetx.cc.vt.edu/AsteroidMeta?action=admin;id=mmj2GrammaticalInductiveSets">Administration</a></span><span class="time"><br /> Last edited 2005-10-12 03:01 UTC by <a class="author" title="from c-69-180-14-134.hsd1.ga.comcast.net" href="jcorneli">jcorneli</a> <a class="diff" href="http://planetx.cc.vt.edu/AsteroidMeta?action=browse;diff=1;id=mmj2GrammaticalInductiveSets">(diff)</a></span><form method="get" action="http://planetx.cc.vt.edu/AsteroidMeta" enctype="application/x-www-form-urlencoded">
<p>Search: <input type="text" name="search"  size="20" accesskey="f" /> <input type="submit" name="dosearch" value="Go!" /></p></form></div>
</body>
</html>
