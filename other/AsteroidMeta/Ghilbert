<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html><head><title>AsteroidMeta: Ghilbert</title><link type="text/css" rel="stylesheet" href="wiki.css" /><meta name="robots" content="INDEX,NOFOLLOW" /><link rel="alternate" type="application/rss+xml" title="AsteroidMeta" href="index.html@action=rss" /><link rel="alternate" type="application/rss+xml" title="AsteroidMeta: Ghilbert" href="http://planetx.cc.vt.edu/AsteroidMeta?action=rss;rcidonly=Ghilbert" /></head><body class="http://planetx.cc.vt.edu/AsteroidMeta"><div class="header"><span class="gotobar bar"><a class="local" href="HomePage">HomePage</a> <a class="local" href="RecentChanges">RecentChanges</a> </span><h1><a title="Click to search for references to this page" href="http://planetx.cc.vt.edu/AsteroidMeta?search=Ghilbert">Ghilbert</a></h1></div><div class="content browse"><p><a class="image" href="ghilbertlogo"><img class="upload" src="download/ghilbertlogo" alt="ghilbertlogo" /></a></p><p>Ghilbert is an extension of <a class="local" href="metamath">metamath</a> designed for collaborative theorem-proving on the Internet. It tries to preserve the simplicity, beauty, and power of the original, but fix several shortcomings. Over and above metamath, Ghilbert has:</p><ul><li>A safe definition mechanism. (In metamath, definitions are conflated with axioms).</li><li>Modules, with import and export. (In metamath, proofs pretty much have to be in one big file).</li><li>Simple s-expression syntax. (In metamath, the grammar is user-defined, and not protected against ambiguity).</li></ul><p>There are a number of minor fixups and changes as well, such as getting rid of the "extended frame", reducing the number of "mandatory hypotheses" that are necessary in proofs (and thus taking away much of the need to store proofs in an ASCII compressed format).</p><p>One important part of the greater Ghilbert project is <a class="local" href="Ghilbert_Pax">Ghilbert Pax</a>, a web of axiomatizations designed to help make proofs easily portable from one system to another.</p><p>I strongly believe that Ghilbert is a good formal basis for a large Web-based repository of mathematical proofs. I would be happy to cooperate with <a class="local" href="The_Hyperreal_Dictionary_of_Mathematics">The Hyperreal Dictionary of Mathematics</a> project if they choose Ghilbert for this role, perhaps adopting it instead of <a class="local" href="index.html@action=browse;oldid=hcode;id=h-code">hcode</a>, or perhaps developing hcode as a competing project to Ghilbert level 1 (as mentioned in <a class="local" href="Ghilbert_syntax_plans">Ghilbert syntax plans</a>), but with a seamless bridge to Ghilbert level 0 so that it can interoperate with the Ghilbert world. That said, there are some philosophical differences between my vision of Ghilbert and that of the HDM. In particular, <a class="local" href="Ghilbert_is_not_AI-complete">Ghilbert is not AI-complete</a>.</p><p>I'm currently in the process of putting together a real release. For a darcs repository of the development, as well as a snapshot and other related files, see the <a class="url outside" href="http://ghilbert.org/">Ghilbert home page.</a></p><p>--<a class="local" href="raph">raph</a></p><h2>Tasks</h2><p>Ghilbert is still in pre-release form. Here are some of the tasks that remain:</p><h3>Specification</h3><p>Ghilbert really needs a clear, up-to-date spec. The "design document" on ghilbert.org, in particular, doesn't reflect the more recent thinking on definitions. The <a class="local" href="Ghilbert_specification">Ghilbert specification</a> is currently being updated collaboratively here on <a class="local" href="AsteroidMeta">AsteroidMeta</a>.</p><h3>Verifier</h3><p>The current verifier prototype, written in Python, is fairly complete (especially now that it includes verification of exports to interfaces from proof files). It is, however, lacking polish in a number of other areas, including error checking and reporting.</p><p>By my count, there are now no less than five independent implementations of <a class="local" href="metamath">metamath</a> verifiers, and it would be very heartening to see something similar for Ghilbert. There are a number of good reasons to write a Ghilbert verifier, so I commend it to people wanting to get involved (of course, having a real spec would help.</p><ul><li>Speed. The Python verifier is a bit pokey for my taste, taking about 20s to run through set_mm.gh on a 2.8GHz P4. A nice implemenation tuned for speed, say in C, could easily gain an order of magnitude, probably more. <b>Update:</b> Dan Krejsa's <a class="url outside" href="http://home.alamedanet.net/~dan.krejsa/shullivan/shullivan.html">Shullivan</a> is exactly such a Ghilbert verifier written in C.</li><li>Your favorite language. I think a Ghilbert verifier is a nice benchmark for comparing languages - the task is complex enough to be interesting (unlike, say, the Towers of Hanoi), but still simple enough that comparing different implementations will probably yield useful results.</li><li>Embedding. Here's where the simplicity of Ghilbert could really pay off. The language is simple enough that it is realistic to implement a verifier within other systems. That could include an Emacs mode for interactively editing proofs, verification for Proof Carrying Code, and, of course, import of Ghilbert theorems into other theorem proving systems.</li></ul><h3>Repository and website</h3><p>The idea is for ghilbert.org to be a central website and repository of proofs, with an easy interface for both browsing the existing database and uploading new proofs to it. I need to figure out what software is best for hosting the site, or whether it's best to roll my own.</p><h3>Connections to other systems</h3><p>One of the central goals of Ghilbert is to make it feasible to translate proofs from other systems into Ghilbert, and also to import Ghilbert proofs into other systems.</p><p>Of these connections, I think HOL has the most immediate potential. The hol.ghi interface is written especially to support proofs translated from HOL.</p><p>In the other direction, a prototype bridge to import Ghilbert proofs into HOL is now posted on the Ghilbert website. Currently, it is capable of importing the entire propositional calculus theory, but needs more work to handle bound variables and definitions.</p><dl class="quote"><dt /><dd>This section is still very sketchy. If there's any interest in taking up one or more of the tasks, put feedback here and I'll try to fill it in.</dd></dl><h3>GUI Application</h3><p>There is now an interactive <a class="local" href="Ghilbert_application">Ghilbert application</a> for creating proofs. It's still in early form, but usable enough to create proofs such as cnsscnp.</p><h2>Discussions</h2><p><a class="local" href="AsteroidMeta">AsteroidMeta</a> has become a cozy home for discussions of Ghilbert, metamath, and related proof topics. By all means, feel free to ask questions here, and I'll do my best to answer. This is a Wiki, after all!</p><p>Here are some of the other wiki pages that may be of interest:</p><ul><li><a class="local" href="Ghilbert_syntax_plans">Ghilbert syntax plans</a></li><li><a class="local" href="GhilbertVsMetamathPart1">GhilbertVsMetamathPart1</a> and <a class="local" href="GhilbertVsMetamathPart2">GhilbertVsMetamathPart2</a></li><li><a class="local" href="Ghilbert_and_HDM">Ghilbert and HDM</a></li></ul><h3>Still active?</h3><p>Hi, is this the correct place to start a new thread?</p><p>Is the GHilbert project still active? There haven't been many changes to this page lately, and <a class="url" href="http://www.ghilbert.org">http://www.ghilbert.org</a> is down.--<a class="local" href="GrafZahl">GrafZahl</a></p><h2>Questions and (maybe) answers</h2><p>{ A few questions/failures in understanding the obvious:</p><p>1. The export/import features are declarative? But what is the mechanism for creating the export files? Does that happen via a utility &#x2013; every time a utility is run (and how are things kept in sync if so).</p><dl class="quote"><dt /><dd>I do have a utility for converting thm's to stmt's (it's very simple, basically just removing the proof and names of the hypotheses), but a lot of the time I create the .ghi file more manually. In fact, I often write the stmt in the .ghi file first, then try to write the proof.</dd><dt /><dd>Keep in mind that not all thm's should be exported as stmt's. The lemmata and so on never go past the .gh file. It's kind of like declaring a function in C static and not putting its prototype into the .h file :)</dd></dl><p>2. Utilization of namespaces, and syntax of the param/import statements are unclear to me.</p><dl class="quote"><dt /><dd>Yes, this is probably one of the biggest areas that needs improvement in the spec. It <i>is</i> a fairly complex and subtle area, and took me months to puzzle out.</dd></dl><p>3. I am increasingly dissatisfied with the Metamath style treatment of (grammatical) type conversions. And yet sub-classing is common in programming languages, not to mention the new Bourbaki language. Should something like the set/class relationship be treated as a  definition or theorem, and removed from the sphere of "syntax" per se &#x2013; meaning that an explicit conversion should be required, either by the user or a a built-in coercion "theorem"?</p><dl class="quote"><dt /><dd>Ghilbert doesn't do any automatic conversions between "kinds". Rather, in my translation of set.mm, I have an explicit (cv x) term. In my axiomatization of HOL, the corresponding term to convert a "var" to a "val" kind is (var x T), where T is a type.</dd><dt /><dd>The distinction between "set" and "class" in set.mm has a lot more to do with the fact that the former is a bindable variable, and less to do with the fact that the latter may not necessarily be a member of V. If you had one kind for both, how would you prevent constructions like E. 3 pi = 3 ?</dd><dt /><dd>It's not obvious how the type/kind distinction should go in other axiomatic frameworks. For a long time, in my axiomatization of Z2, I had separate kinds for nats and sets of nats (actually a total of four, because variables and values for both). Right now, I have one kind for both, and always state the type explicitly in quantifiers. I'm not sure which is better, frankly.</dd><dt /><dd>Another area in which I can imagine using the kind mechanism more fully is to implement the restrictions on formulae in the various subsets of second order arithmetic in Simpson's book. I haven't created files for any of that yet, though.</dd></dl><p>4. Will the user be able to apply the notation of his/her choice to the gh/ghi modules? So Norm could use set.mm's notation and another person could use, say, Polish notation?</p><dl class="quote"><dt /><dd>There are definitely going to be translations between different syntax notations. The details are not entirely clear to me yet. The idea of .ghi files with really simple s-exp notation is important, because that's <i>much</i> easier for tools to deal with than requiring powerful parsing.</dd><dt /><dd>So how do we deal with both? The simplest way is just to have tools for translating in both directions (this already exists to a significant degree with Metamath). A fancier way is to do the translations "on the fly," for example in the UI of an interactive app.</dd></dl><p>4.B I suggest separating notation specifications from the other files, perhaps with a ".ghn" file providing notation.</p><p>5. Are Bourbaki and Ghilbert going to be unified  conceptually? (I would like to view Bourbaki and Ghilbert as format and interface specifications rather than looking at, say, Bourbaki as a Lisp program&#x2026;but they are already very closely related&#x2026;)</p><dl class="quote"><dt /><dd>I think your question gets to the heart of the reason why these are two different projects. Ghilbert is intended to be a simple, self-contained spec. Bourbaki, because it allows programming, includes by reference all of Common Lisp, which is pretty heavyweight. Thus, it's quite infeasible (though possible in principle; Turing completeness and all) to embed a Bourbaki verifier (and thus importer) into, say, HOL.</dd><dt /><dd>Do proofs need a programming language? That's a difficult question. The biggest issue is proof size - you certainly wouldn't want to do heavy arithmetic directly in Ghilbert (or Metamath). But, on the other hand, the entire set.mm is a testament to the fact that you don't <i>need</i> programming features to do a good job over a wide range of real mathematics.</dd><dt /><dd>My favorite approach for getting some of the best of both worlds is to use a "proof compiler" to go from higher levels (with programming) to lower (without). The result is basically a proof in "machine code". The big advantage is that you can verify this compiled proof using only very simple tools. Also, as long as the technical details are worked out, you should be able to mix and match proofs translated from several different source languages, and have everything verify in a  clean, formal sense.</dd><dt /><dd>A quick way to get there would be for Bourbaki to output a "trace" of its proof as a Ghilbert .gh file. At heart, this should be pretty easy, but the devil is always in the details. I haven't studied how Bourbaki deals with definitions, in particular.</dd></dl><p>5.B I was, of course, disappointed with incorporation of Lisp by reference ("lisp-form") in the specification. I see how it might be useful though. Still, one not take advantage of this "feature", and that wasn't exactly what I was thinking about. One thing Bourbaki provides is the ability to specify a "bound" variable. It does that in addition to distinct variable specifications. Bourbaki also glumps the hierarchy of namespaces into "contexts", with a "root-context". I'm not clear on how all of this works in practice. And perhaps Ghilbert doesn't need to have the free/bound concept.</p><dl class="quote"><dt /><dd><a class="local" href="Bourbaki_proof_checker">a comment about the Bourbaki context system</a></dd><dt /><dd>comment from <a class="local" href="raph">raph</a>: I haven't dug deeply into Bourbaki yet, but I'm going to take a wild guess that the concept of "bound variables" exists primarily to make definitions work; a dummy appearing in a definition is safe (and can be alpha-converted without loss of meaning) if it is bound, but potentially dangerous otherwise. In Ghilbert, I've carefully worked out rules entirely in terms of distinct variables, so that (unless I've made a mistake), definitions not using bound variables, or using a hybrid of bound and free variables as in the definition of substitution, are also safe. I do plan to study Bourbaki's approach to definitions in more detail, but in the meantime if somebody has more to say about which approach is better, I'd love to hear it. --<a class="local" href="raph">raph</a></dd></dl><p>} --<a class="local" href="ocat">ocat</a> p.s. I look forward to one day working on  Ghilbert related topics. At this moment I <b>really</b> want to develop a proof assistant GUI, and am working hard to learn Python and Tkinter. Anyone wants to send me an IQ upgrade, post a note&#x2026;I don't like thrashing any more than the next person, though I suspect that discomfort and suffering are prerequisites for (my) education :)</p><dl class="quote"><dt /><dd>Not to throw cold water, but a GUI app is a pretty ambitious goal. The kind of tool I have in mind for Ghilbert even more so, because I want it to do real 2D math typesetting, which is of course an ambitious goal even without making it do formal proofs. I'm taking it in stages - certainly I want to get a batch parser working before even attempting to do it interactively. The important thing is to enjoy each step along the way, without getting too caught up in the final results.</dd><dt /><dd>Of course, all contributions to the Ghilbert universe are greatly appreciated, and, who knows, you might come up with a usable tool before I do - my perfectionism and the fact that I have a life guarantee that my tool won't be ready any time soon.</dd></dl><p>{If I cannot create a proof assistant GUI for Metamath then I'm going to have to hang up my keyboard :) I feel that it is essential to have a GUI for working with this stuff. Not necessarily for "experts", but for the novices who cannot bear the Mt. Everest learning curve. People today expect a GUI interface. They don't want to read-read-read and then do, they want to do-do-do and then reboot and try again. A lot of the learning process in logic is, like math, linguistic. That means transference of knowledge to the frontal lobes and wiring it in. (Notice how Norm's set.mm propositional logic theorems are basically just about moving symbols into different patterns &#x2013; a sub-verbal activity.) Wiring in the skills requires lots of practice, and doing that in batch mode is ugly. Pencil and paper work too, of course&#x2026;}--<a class="local" href="ocat">ocat</a></p><p>You might be interested in my description of Ghilbert's <a class="local" href="Core_Proof_Language">Core Proof Language</a>. --<a class="local" href="marnix">marnix</a> 15 June 2006</p><h2>Possible design changes</h2><p>I'm considering a few small changes to the design. This is a good place to leave feedback. Note: as of the latest development version (2005-11-21), both of these proposals are implemented. However, the dv conditions in the database mostly have not yet been trimmed.</p><h3>RPN vs terms in proofs</h3><p>Currently, terms occurring in proofs are in RPN format. So, to prove (&#x2192; (\/ ph ps) (\/ ph ps)), you'd write:</p><pre>  ph ps \/ id</pre><p>A consequence is that terms and theorems share a namespace. This causes a few collisions when the set.mm database is translated to Ghilbert, including 1o, 2o, and exp. To fix this, and possibly to improve readability, I'm considering changing it to writing the terms inline:</p><pre>  (\/ ph ps) id</pre><p>Variables and theorems would still share namespace, but that seems like a minor issue, especially as there are no such collisions in set.mm.</p><p><em>RPN is fine, and Lisp syntax is fine. But they sort of go in opposite directions, don't they? It seems like it would be confusing. You could, instead, format the whole proof in Lisp syntax:</em></p><pre>  (id (\/ ph ps))</pre><p><em>I like how applying a theorem here looks exactly like applying a procedure in a Scheme program. I can't tell if this solves your namespace problem or not, though. --jorend</em></p><p><em>&#x2026;Surely if you ask Norm really nicely he'll rename the exp theorem and the handful of others that cause problems. No? --<a class="local" href="jorend">jorend</a> 11 Oct 2006</em></p><dl class="quote"><dt /><dd>On June 24, 2006, the Metamath spec was officially changed to prohibit label and math symbol namespace collisions, and set.mm was changed to conform to the new spec. E.g. the 'exp' theorem was renamed to 'ex'. So any Ghilbert translation since then shouldn't have this problem. --<a class="local" href="norm">norm</a> 12 Oct 2006</dd></dl><p>Presumably it is easy enough to create a new namespace for theorems? At least in lisp&#x2026; --<a class="local" href="jcorneli">jcorneli</a></p><hr /><p>I have made the change to s-expressions rather than RPN for terms in proofs, and am very happy with the decision. Ironically, that means that Metamath and Ghilbert have now completely switched places with respect to the question of whether a term and theorem sharing the same name is allowed. I personally would have no problem with the requirement being removed from the Metamath spec, but this might be problematic for other Metamath implementation work.</p><p>Switching to s-expressions for the proofs, as jorend proposes, would reintroduce the namespace separation problem, because currently a proof step which is an atom is known to be either a variable, hypothesis, or stmt name, and all other steps are known to be terms. If a proof becomes a tree represented in s-expression form, rather than a sequence of proof steps, then this distinction is no longer available.</p><p>I have a few other stylistic reasons for preferring the sequence approach. First, it is more flexible for representing incomplete or broken proofs (important in interactive settings). Second, there is less work in rearranging proofs, as simple cut-and-paste of lines usually suffices, with no additional fixup of parentheses.</p><p>And third, I like not having to explicitly show deep nesting with calculational proofs involving long chains of equality, biconditionals, and indentations. I've chosen a preferred indentation policy based on this principle as well: the indentation level is equal to the stack depth after the last step on the line.</p><pre>   proof that A = B
     proof that B = C
   eqtr
     proof that C = D
   eqtr
     proof that D = E
   eqtr</pre><p>To me, this style of proof of A = E captures at least some of the flavor of Dijkstra and Scholten's calculational proofs. You can see some examples amongst the new proofs in  <a class="url outside" href="http://ghilbert.org/repo/ghilbert/hol/hol-zfc.gh">hol-zfc.gh</a>, such as df-$\/-half  and df-$\/.</p><p>&#x2013; <a class="local" href="raph">raph</a> 17 Oct 2006</p><h3>Distinct variable conditions on dummies</h3><p>Right now, Ghilbert enforces the same distinct variable conditions as Metamath (where they are written as $d statements). I'm considering requiring only dv constraints on variables listed in the hypotheses and result; dummies that occur only inside the proof would automatically be considered distinct.</p><p><a class="local" href="marnix">marnix</a> has implemented this more liberal policy in <a class="url outside" href="http://www.solcon.nl/mklooster/repos/hmm/">Hmm</a>, and suggests that I do the same in Ghilbert.</p><p>&#x2014;</p><p>?</p></div><div class="footer"><hr /><span class="gotobar bar"><a class="local" href="HomePage">HomePage</a> <a class="local" href="RecentChanges">RecentChanges</a> </span><span class="edit bar"><br /> <a class="edit" accesskey="e" title="Click to edit this page" href="http://planetx.cc.vt.edu/AsteroidMeta?action=edit;id=Ghilbert">Edit this page</a> <a class="history" href="http://planetx.cc.vt.edu/AsteroidMeta?action=history;id=Ghilbert">View other revisions</a> <a class="admin" href="http://planetx.cc.vt.edu/AsteroidMeta?action=admin;id=Ghilbert">Administration</a></span><span class="time"><br /> Last edited 2008-03-26 18:47 UTC by <a class="author" title="from 66-81-75-111.bayarea.dialup.o1.com" href="ocat">ocat</a> <a class="diff" href="http://planetx.cc.vt.edu/AsteroidMeta?action=browse;diff=1;id=Ghilbert">(diff)</a></span><form method="get" action="http://planetx.cc.vt.edu/AsteroidMeta" enctype="application/x-www-form-urlencoded">
<p>Search: <input type="text" name="search"  size="20" accesskey="f" /> <input type="submit" name="dosearch" value="Go!" /></p></form></div>
</body>
</html>
