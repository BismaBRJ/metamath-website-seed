<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html><head><title>AsteroidMeta: mmj2ProofCompressionNotes</title><link type="text/css" rel="stylesheet" href="wiki.css" /><meta name="robots" content="INDEX,NOFOLLOW" /><link rel="alternate" type="application/rss+xml" title="AsteroidMeta" href="index.html@action=rss" /><link rel="alternate" type="application/rss+xml" title="AsteroidMeta: mmj2ProofCompressionNotes" href="http://planetx.cc.vt.edu/AsteroidMeta?action=rss;rcidonly=mmj2ProofCompressionNotes" /></head><body class="http://planetx.cc.vt.edu/AsteroidMeta"><div class="header"><span class="gotobar bar"><a class="local" href="HomePage">HomePage</a> <a class="local" href="RecentChanges">RecentChanges</a> </span><h1><a title="Click to search for references to this page" href="http://planetx.cc.vt.edu/AsteroidMeta?search=mmj2ProofCompressionNotes">mmj2ProofCompressionNotes</a></h1></div><div class="content browse"><h1>A throwaway page of rough notes</h1><p>A now obsolete theorem in set.mm, "climadd2OLD" has a proof that expands to approximately 15,000 steps (in Metamath RPN format).</p><p>As an experiment I used metamath.exe to repeatedly compress and decompress its proof. Surpisingly &#x2013; to me &#x2013; the compression of climadd2OLD takes about 1 second (subjective estimation), plus/minus .2 seconds.</p><p>This is not totally surprising though because of the significant amount of work required to scan an array of 15,000 proof steps looking for duplicate subproofs. I estimate that if there were, approximately, 7,500 assertions requiring inspection (1/2), and an average traversal of 7,500 steps, then 56 million equality comparisons would be needed just to find duplicate subproof roots (plus/minus).</p><p>There are other tasks involved in compressing a Metamath proof, and I won't go over all that right this moment, but the point is that the process is computationally intensive! We can refine the workload estimates for a given proof, but it is clear that a lot of work is involved in going back, after the fact of successful proof creation and turning an array of label strings into an array of numerically compressed symbols in the Metamath.pdf format.</p><p>For metamath.exe the <b>price</b> of compression is definitely "worth it" because metamath.exe processes compressed proofs directly in its Proof Verifier, and because there is no need to decompress a proof unless the user requests it.</p><p>For mmj2 the question is different because mmj2's Proof Verifier does not presently operate upon compressed proofs, though it could one day. And throughout mmj2 processing the standard format is decompressed. Fortunately, decompression promises to be fairly swift, so file loading will likely not be slowed greatly when reading a file with compressed proofs. However, the Proof Assistant may indeed be somewhat slower than seen now. The average unification time for a Metamath proof is 1/10th of a second, and long proofs require something like 3/10th of a second. So, if a user desires to see generated proofs in compressed format, response time for the gnarliest proof could increase to 1 second or more!</p><p>That is interesting. The alternative is to accept uncompressed output from mmj2's Proof Assistant for the sake of somewhat speedier response times. The decompressed proofs could be cut-and-pasted into Metamath.exe and compressed &#x2013; or, an option could be provided on the GUI to toggle back and forth between compressed and uncompressed formats (that is the likely approach&#x2026;)</p><ul><li>* *</li></ul><p>One possible algorithm for compressing a Metamath proof involves a bottom-up, left-right traversal generating a hash code for each subtree containing an assertion in the subtree's root. If no match, add it and output the original symbol sequence; otherwise, double-check for equality and if equal, plug in the reference number for the Metamath compressed proof.</p><p>There are details that would need to be worked out in this approach. But it is not clear just how much would be saved given the expense of creating  objects to store in the hashmap, etc. However, as a gedankenexperiment, the hashmap approach has merit &#x2013; it would be more widely useful if the method were used thoughout processing. To use a complicated algorithm just to compress one proof and then throw everything away may not be justified, but in the context of an <b>entire</b> system for  creating and manipulating proofs, the investment might generate a positive return.</p><ul><li>* *</li></ul><p>One thing is very clear to me in hindsight: I should have created a first class "Proof" object in mmj2 instead of coding "proof" as Stmt[] in Theorem (i.e. as an array of Stmt object references.) If, in  metamath.exe Proof Verification is quicker when  operating on compressed proofs, might not proof trees  be faster and more efficient if there were a mechanism for stubbing out "virtual" tree nodes to replace repeated subproofs &#x2013; and if each node contained a hashcode, ready for use at a moment's notice (just an idea.)</p><p>Actually, it is not too late to retrofit mmj2 with Proof objects. Proof references are not so numerous as to make the upgrade task unmanageable. At any rate, add this to "Lessons Learned" &#x2013; or partially learned, for there are many other interesting avenues to investigate&#x2026;</p><p>Ghilbert's proof format is intrinsically more concise than Metamath's because it does not store variable substitutions at a given tree level  unless the variable is referenced in that level's assertion. And Ghilbert externalizes proofs, which seems like a good idea on the simple grounds that there may be multiple meritorious proofs for a given theorem.</p><p>Another area to look at is using subtree hashcodes in proof unification lookups &#x2013; and subtree matching.</p><p>The problem of how to actually <b>do</b> proof unification in a speedy manner against a database containing 1,000,000 assertions is unresolved in mmj2. It seems clear that 2D database techniques are needed, but the precise organization of such a database has not been designed. At present, with set.mm at 7,000 some theorems and the likelihood of next years PC's  coming standard with 1 or 2GB of RAM, the problem does not require an instant solution. (As long as Microsoft bloats Windows faster than Norm Megill adds theorems to set.mm, we're ok!)</p><p>--<a class="local" href="ocat">ocat</a> 20-Mar-2006</p><h1>mmj2 loads compressed 1/28 set.mm 50% faster than uncompressed set.mm</h1><p>Fascinating. Takes about 3 seconds to load the "LogicalSystem<a class="edit" title="Click to edit this page" href="http://planetx.cc.vt.edu/AsteroidMeta?action=edit;id=LogicalSystem">?</a>" data structure from the 1/28 compressed version of set.mm, which weighs in at +12MB uncompressed &#x2013; and the uncompressed version takes +/- 6 seconds to load. I theorize that the reduction is due to a combination of factors including a) few disk i/o's, b) fewer tokens to parse; c) fewer ASCII characters to validate; d) fewer Metamath proof labels to validate. On the last item, 'd', the compression routine does not need to check the Stmt tbl hashmap for every input label, only the parenthesized labels in the compressed proofs &#x2013; the remaining labels are generated via direct index lookup (i.e. reusing the prior validations).</p><p>So that's good, especially because this cuts down the startup time for the Proof Assistant. BTW, the mmj2 "Verify Proofs *" takes about the same amount of time &#x2013; about 3 seconds &#x2013; that metamath.exe takes, in spite of the fact that mmj2 processes uncompressed proofs internally. That would seem to imply that additional runtime reductions can be achieved by modifying the mmj2 VerifyProof<a class="edit" title="Click to edit this page" href="http://planetx.cc.vt.edu/AsteroidMeta?action=edit;id=VerifyProof">?</a> logic to handle compressed proofs directly.</p><p>--<a class="local" href="ocat">ocat</a> 20-Mar-2006</p></div><div class="footer"><hr /><span class="gotobar bar"><a class="local" href="HomePage">HomePage</a> <a class="local" href="RecentChanges">RecentChanges</a> </span><span class="edit bar"><br /> <a class="edit" accesskey="e" title="Click to edit this page" href="http://planetx.cc.vt.edu/AsteroidMeta?action=edit;id=mmj2ProofCompressionNotes">Edit this page</a> <a class="history" href="http://planetx.cc.vt.edu/AsteroidMeta?action=history;id=mmj2ProofCompressionNotes">View other revisions</a> <a class="admin" href="http://planetx.cc.vt.edu/AsteroidMeta?action=admin;id=mmj2ProofCompressionNotes">Administration</a></span><span class="time"><br /> Last edited 2006-03-21 01:27 UTC by <a class="author" title="from 66-81-75-155.bayarea.dialup.o1.com" href="ocat">ocat</a> <a class="diff" href="http://planetx.cc.vt.edu/AsteroidMeta?action=browse;diff=1;id=mmj2ProofCompressionNotes">(diff)</a></span><form method="get" action="http://planetx.cc.vt.edu/AsteroidMeta" enctype="application/x-www-form-urlencoded">
<p>Search: <input type="text" name="search"  size="20" accesskey="f" /> <input type="submit" name="dosearch" value="Go!" /></p></form></div>
</body>
</html>
